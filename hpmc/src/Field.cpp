#include <sstream>
#include "Field.hpp"
#include "Constants.hpp"
#include "Logger.hpp"

using namespace HPMC;

static const std::string package = "HPMC.field";

Field::Field( HPMCConstants* constants )
    : m_constants( constants )
{
    m_binary = false;
    m_size[0] = 0;
    m_size[1] = 0;
    m_size[2] = 0;
    m_cells[0] = 0;
    m_cells[1] = 0;
    m_cells[2] = 0;
    m_extent[0] = 1.0f;
    m_extent[1] = 1.0f;
    m_extent[2] = 1.0f;

    m_mode = HPMC_VOLUME_LAYOUT_TEXTURE_3D;
    m_shader_source = "";
    m_tex = 0;
    m_tex_field_channel = GL_RED;
    m_tex_gradient_channels = GL_NONE;
}

bool
Field::configure()
{
    Logger log( m_constants, package + ".configure" );

    if( (m_size[0] < 2) ||
        (m_size[1] < 2) ||
        (m_size[2] < 2) ||
        (16384 < m_size[0]) ||
        (16384 < m_size[1]) ||
        (16384 < m_size[2]) )
    {
        std::stringstream o;
        o << "Insane field size ("
                       << "field.size = [ "
                       << m_size[0] << " x "
                       << m_size[1] << " x "
                       << m_size[2] << " ]";
        log.errorMessage( o.str() );
        return false;
    }
    if( (m_size[0] <= m_cells[0] ) ||
        (m_size[1] <= m_cells[1] ) ||
        (m_size[2] <= m_cells[2] ) )
    {
        std::stringstream o;
        o << "Field is smaller than cells ("
                       << "field.size = [ "
                       << m_size[0] << " x "
                       << m_size[1] << " x "
                       << m_size[2] << " ], "
                       << "field.cells = [ "
                       << m_cells[0] << " x "
                       << m_cells[0] << " x "
                       << m_cells[0] << " ] )";
        log.errorMessage( o.str() );
        return false;
    }
    return true;
}


const std::string
Field::fetcherSource(bool gradient) const
{
    using std::endl;
    std::stringstream src;


    src << "// generated by HPMC.Field.fetcherSource" << endl;
    // -------------------------------------------------------------------------
    if( m_mode == HPMC_VOLUME_LAYOUT_TEXTURE_3D ) {
        std::string field_channel = "r";
        switch( m_tex_field_channel ) {
        case GL_RED:
            field_channel = "r";
            break;
        case GL_ALPHA:
            field_channel = "a";
            break;
        default:
            break;
        }
        src << "uniform sampler3D  HPMC_scalarfield;" << endl;
        src << "float" << endl;
        src << "HPMC_sample( vec3 p )" << endl;
        src << "{" << endl;
        src << "    p.z = (p.z+0.5)*(1.0/float(" << m_size[2]<< "));" << endl;
        if( m_constants->target() < HPMC_TARGET_GL30_GLSL130 ) {
            src << "    return texture3D( HPMC_scalarfield, p )." << field_channel << ";" << endl;
        }
        else {
            src << "    return texture( HPMC_scalarfield, p )." << field_channel << ";" << endl;
        }
        src << "}" << endl;
        if( gradient && hasGradient() ) {
            src << "vec4" << endl;
            src << "HPMC_sampleGrad( vec3 p )" << endl;
            src << "{" << endl;
            src << "    p.z = (p.z+0.5)*(1.0/float(" << m_size[2]<< "));" << endl;
            if( m_constants->target() < HPMC_TARGET_GL30_GLSL130 ) {
                src << "    return texture3D( HPMC_scalarfield, p );" << endl;
            }
            else {
                src << "    return texture( HPMC_scalarfield, p );" << endl;
            }
            src << "}" << endl;
        }
    }
    else if( m_mode == HPMC_VOLUME_LAYOUT_CUSTOM ) {
        src << m_shader_source << endl;
        src << "float" << endl;
        src << "HPMC_sample( vec3 p )" << endl;
        src << "{" << endl;
        src << "    p.z = (p.z+0.5)*(1.0/float(" << m_size[2]<< "));" << endl;
        src << "    return HPMC_fetch( p );" << endl;
        src << "}" << endl;
        if( gradient && hasGradient() ) {
            src << "vec4" << endl;
            src << "HPMC_sampleGrad( vec3 p )" << endl;
            src << "{" << endl;
            src << "    p.z = (p.z+0.5)*(1.0/float(" << m_size[2]<< "));" << endl;
            src << "    return HPMC_fetchGrad( p );" << endl;
            src << "}" << endl;
        }
    }
    // -------------------------------------------------------------------------
    else {
        Logger log( m_constants, package + ".fetcherSource" );
        log.errorMessage( "Unknown fetch mode" );
        return "";
    }
    return src.str();
}

/** configures a program that uses fetcher source. */
bool
Field::setupProgram( Field::Context& context, GLuint program ) const
{
    Logger log( m_constants, package + ".setupProgram" );
    bool retval = true;
    if( m_mode != HPMC_VOLUME_LAYOUT_CUSTOM ) {
        context.m_loc_tex = glGetUniformLocation( program, "HPMC_scalarfield" );
    }
    else {
        context.m_loc_tex = -1;
    }
    return retval;
}

/** binds textures and updates fetcher uniform values. */
bool
Field::bind( const Context& context, GLuint texture_unit ) const
{
    Logger log( m_constants, package + ".bind" );

    if( m_mode == HPMC_VOLUME_LAYOUT_TEXTURE_3D ) {
        if( m_constants->debugBehaviour() != HPMC_DEBUG_NONE ) {
            std::stringstream o;
            o << "unit=" << texture_unit
              << ", loc=" << context.m_loc_tex
              << ", tex=" << m_tex;
            log.debugMessage( o.str() );
        }

        glUniform1i( context.m_loc_tex, texture_unit );
        glActiveTextureARB( GL_TEXTURE0_ARB + texture_unit );
        glBindTexture( GL_TEXTURE_3D, m_tex );
    }
    return true;
}

